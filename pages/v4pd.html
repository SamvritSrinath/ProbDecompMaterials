<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Homework 9: Advanced Scenarios</title>
    <link rel="stylesheet" href="../css/styles.css" />
    <link rel="stylesheet" href="../lib/highlight/styles/github.min.css" />
    <script>
      if (sessionStorage.getItem('authenticated') !== 'true') {
        window.location.href = 'auth.html';
      }
    </script>
  </head>
  <body>
    <div class="page-container">
      <aside class="sidebar">
        <div>
          <h3>Problem Sets</h3>
          <nav>
            <ul>
              <li><a href="v1pd.html">Homework 5</a></li>
              <li><a href="v12pd.html">Homework 6</a></li>
              <li><a href="v2pd.html">Homework 7</a></li>
              <li><a href="v3pd.html">Homework 8</a></li>
              <li><a href="v4pd.html" class="active">Homework 9</a></li>
              <!-- <li><a href="finalexam.html">Final Exam</a></li> -->
            </ul>
          </nav>
        </div>
        <a href="../index.html" class="sidebar-home-link">Go Home</a>
      </aside>
      <main class="content">
        <header>
          <h1>Homework 9: Advanced Decomposition Scenarios</h1>
          <nav class="toc-container">
            <h3>Table of Contents</h3>
            <ul id="toc"></ul>
          </nav>
        </header>

        <h2 class="suite-title">Question Suite 1: Checkerboard Image Merge</h2>

        <div class="question" id="q1">
          <h2>Code Writing: Determine Checkerboard Square Type</h2>
          <p>
            <strong>Task:</strong> The checkerboard effect is often generated by
            dividing an image up into even-sized squares, checking the
            “position” of the pixel based on the x,y as well as a “square”size
            parameter to determine a class of square. The alternation of these
            class of squares generates the checkerboard effect (i.e. type 0,
            type 1, type 0, type 1…). The square_side_length parameter
            conceptually divides an image into a grid of squares. For any pixel
            at coordinates (px, py), we can determine which square in this grid
            it belongs to. The "grid column" can be found by grid_col = px //
            square_side_length, and the "grid row" by grid_row = py //
            square_side_length. Our checkerboard pattern alternates between two
            types of squares, let's call them "type 0" and "type 1". A common
            way to achieve an alternating pattern is to sum the grid_row and
            grid_col. If this sum is even, the square is one type; if the sum is
            odd, it's the other type. For our purposes, the square containing
            the image origin (0,0) (which corresponds to grid_row=0, grid_col=0)
            will be "type 0".
          </p>
          <p>
            Write a Python function
            <code
              >get_square_type(px: int, py: int, square_side_length: int) ->
              int</code
            >. This function should:
          </p>
          <ol>
            <li>
              Calculate the grid_row and grid_col for the pixel (px, py) based
              on square_side_length.
            </li>
            <li>Determine if the sum (grid_row + grid_col) is even or odd.</li>
            <li>Return 0 if the sum is even (this is a "type 0" square).</li>
            <li>Return 1 if the sum is odd (this is a "type 1" square).</li>
          </ol>
          <p>
            Assume square_side_length will always be a positive integer (e.g., 1
            or greater).
          </p>
          <pre><code class="language-python">
def get_square_type(px: int, py: int, square_side_length: int) -> int:
    """
    Determines the type of checkerboard square (0 or 1) for a pixel.
    A square at grid (row, col) is type 0 if (row + col) is even, type 1 if odd.
    
    Args:
        px: The x-coordinate of the pixel.
        py: The y-coordinate of the pixel.
        square_side_length: The side length (positive integer) of each checkerboard square.
    Returns:
        0 or 1, representing the type of the square.
    """
    # Your code here:
    # Calculate grid_row and grid_col.
    # Check if (grid_row + grid_col) is even or odd.
    # Return 0 for even sum, 1 for odd sum.
    pass # Remove this line
                </code></pre>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <pre><code class="language-python">
# Solution Code:
def get_square_type(px: int, py: int, square_side_length: int) -> int:
    """
    Determines the type of checkerboard square (0 or 1) for a pixel.
    A square at grid (row, col) is type 0 if (row + col) is even, type 1 if odd.
    
    Args:
        px: The x-coordinate of the pixel.
        py: The y-coordinate of the pixel.
        square_side_length: The side length (positive integer) of each checkerboard square.
    Returns:
        0 or 1, representing the type of the square.
    """
    grid_row = py // square_side_length
    grid_col = px // square_side_length
    
    sum_of_indices = grid_row + grid_col
    
    if sum_of_indices % 2 == 0:
        return 0  # Type 0 for even sum
    else:
        return 1  # Type 1 for odd sum
                </code></pre>
          </div>
        </div>

        <div class="question" id="q2">
          <h2>Code Writing: Select Pixel Based on Square Type</h2>
          <p>
            <strong>Task:</strong> In our checkerboard merge effect, after
            determining the square_type (which will be 0 or 1) for a given pixel
            location, we need to select the actual pixel color from either the
            top_image_pixel or the bottom_image_pixel. Let's establish a rule:
          </p>
          <ul>
            <li>If square_type is 0, we select bottom_image_pixel.</li>
            <li>If square_type is 1, we select top_image_pixel.</li>
          </ul>
          <p>
            Write a Python function
            <code
              >select_pixel_for_overlay(top_pixel_color: tuple[int, int, int],
              bottom_pixel_color: tuple[int, int, int], square_type: int) ->
              tuple[int, int, int]</code
            >. This function takes the (R,G,B) color tuple of the pixel from the
            top image, the (R,G,B) color tuple of the pixel from the bottom
            image, and the square_type (an integer, either 0 or 1). It should
            return the chosen (R,G,B) color tuple based on the rule above.
          </p>
          <p>Hint: Don’t overthink this question!</p>
          <pre><code class="language-python">
def select_pixel_for_overlay(top_pixel_color: tuple, bottom_pixel_color: tuple, square_type: int) -> tuple:
    """
    Selects either the top or bottom pixel color based on the square_type.
    Args:
        top_pixel_color: (R,G,B) tuple from the top image.
        bottom_pixel_color: (R,G,B) tuple from the bottom image.
        square_type: An integer (0 or 1) indicating the checkerboard square type. 0 means use bottom_pixel_color, 1 means use top_pixel_color.
    Returns:
        The selected (R,G,B) color tuple.
    """
    # Your code here:
    # Implement the selection logic based on square_type.
    pass # Remove this line
                </code></pre>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <pre><code class="language-python">
# Solution Code:
def select_pixel_for_overlay(top_pixel_color: tuple, bottom_pixel_color: tuple, square_type: int) -> tuple:
    """
    Selects either the top or bottom pixel color based on the square_type.
    """
    if square_type == 1:
        return top_pixel_color
    else:
        return bottom_pixel_color
                </code></pre>
          </div>
        </div>

        <div class="question" id="q3">
          <h2>Testing: Checkerboard Square Type Logic</h2>
          <p>
            <strong>Question:</strong> You are testing the Python function
            <code
              >get_square_type(px: int, py: int, square_side_length: int) ->
              int</code
            >
            from an earlier question. This function is designed to determine if
            a pixel at (px, py) belongs to a "type 0" or "type 1" square in a
            checkerboard pattern. The square_side_length defines the side length
            of each square. The logic is: grid_row = py // square_side_length,
            grid_col = px // square_side_length. The function returns 0 if
            (grid_row + grid_col) is even, and 1 if it's odd. Your goal is to
            test it thoroughly using a minimal but diverse set of test cases
            from the list provided below.
          </p>
          <p>
            Test Cases (Input: (px, py, square_side_length), Expected Output):
          </p>
          <ul>
            <li>TC1: (0, 0, 10) -> 0 (Grid (0,0), sum 0, type 0)</li>
            <li>TC2: (9, 9, 10) -> 0 (Still in grid (0,0), sum 0, type 0)</li>
            <li>TC3: (10, 0, 10) -> 1 (Grid (0,1), sum 1, type 1)</li>
            <li>TC4: (0, 10, 10) -> 1 (Grid (1,0), sum 1, type 1)</li>
            <li>TC5: (10, 10, 10) -> 0 (Grid (1,1), sum 2, type 0)</li>
            <li>TC6: (5, 5, 10) -> 0 (Middle of grid (0,0), sum 0, type 0)</li>
            <li>TC7: (0, 0, 1) -> 0 (Grid (0,0) with size 1, sum 0, type 0)</li>
            <li>TC8: (1, 0, 1) -> 1 (Grid (0,1) with size 1, sum 1, type 1)</li>
            <li>TC9: (25, 15, 5) -> 0 (Grid (3,5), sum 8, type 0)</li>
            <li>TC10: (2, 3, 2) -> 0 (Grid (1,1), sum 2, type 0)</li>
          </ul>
          <p>
            Which of the following sets of test cases provides the best minimal
            but diverse testing for the get_square_type function, covering
            different positions relative to square boundaries (within, on edge),
            different grid arrangements resulting from these positions, and edge
            cases for square_side_length?
          </p>
          <ol type="A">
            <li>TC1, TC2, TC6, TC7, TC8</li>
            <li>TC1, TC2, TC3, TC4, TC5</li>
            <li><b>TC1, TC2, TC3, TC4, TC7, TC9</b></li>
            <li>TC1, TC2, TC3, TC4, TC5, TC6, TC9, TC10</li>
          </ol>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <p><strong>Correct Option: C</strong></p>
            <p>
              <strong>Feedback:</strong>
            </p>
            <ul>
              <li>
                <b>A) Incorrect.</b> This set tests being within a square (TC2,
                TC6) and basic origin/edge cases with square_side_length=10 and
                square_side_length=1. However, does it sufficiently test
                transitions across square boundaries for different
                square_side_length values or different grid coordinates?
              </li>
              <li>
                <b>B) Incorrect.</b> This set thoroughly tests a single
                square_side_length (10) by checking the origin (TC1), within a
                square (TC2), and all immediate neighboring squares (TC3, TC4,
                TC5). Is this diverse enough? Consider if it tests different
                square_side_length values or grid coordinates further from the
                origin.
              </li>
              <li>
                <b>C) Correct.</b> This set effectively covers: The origin (TC1)
                and within the first square (TC2) for square_side_length = 10.
                Transitions to adjacent squares horizontally (TC3) and
                vertically (TC4) for square_side_length = 10. An edge case with
                square_side_length = 1 (TC7). A different square_side_length (5)
                and different grid coordinates (TC9), testing the general logic.
                This provides good coverage without excessive redundancy.
              </li>
              <li>
                <b>D) Incorrect.</b> While this set offers very broad coverage,
                the goal is also minimal diverse testing. Does this set include
                redundant tests or test cases that don't add significantly new
                information compared to a smaller, well-chosen set? For example,
                are TC5, TC6, and TC10 all strictly necessary if other cases
                already test similar logic?
              </li>
            </ul>
          </div>
        </div>

        <div class="question" id="q4">
          <h2>Closed-Box Debugging: Checkerboard Pattern Appears as Stripes</h2>
          <p>
            <strong>Scenario:</strong> You are using a Python function
            <code
              >apply_checkerboard_merge(img_top, img_bottom, square_size)</code
            >. This function is supposed to merge img_top and img_bottom (both
            of the same dimensions) using a checkerboard pattern of a given
            square_size. In "type 0" squares (e.g., the one at (0,0)), pixels
            from img_bottom should be shown. In "type 1" squares, pixels from
            img_top should be shown. The type is determined by the sum of
            grid_row and grid_col indices being even (type 0) or odd (type 1).
          </p>
          <p>
            <strong>Observed Problem:</strong> You call the function with
            <code>square_size = 20</code>. Instead of seeing a 20x20
            checkerboard pattern in the output result image, you observe that
            the result image is composed of vertical stripes. There are 20-pixel
            wide vertical stripes(i.e. Portions of the image from the top of the
            resultant image to the bottom) taken entirely from img_bottom,
            alternating with 20-pixel wide vertical stripes taken entirely from
            img_top. The pattern does not change vertically; a column of pixels
            always belongs to the same source image strip.
          </p>
          <p>
            <strong>Question:</strong> You do not have access to the function's
            source code. What is the most likely logical error in how the
            function determines which image to pick pixels from?
          </p>
          <ol type="A">
            <li>
              The function is always choosing <code>img_top</code> regardless of
              the pixel's position.
            </li>
            <li>
              The function is calculating grid_row = py // square_size and
              grid_col = px // square_size, but then only uses the parity of
              grid_row (i.e., grid_row % 2) to decide between img_top and
              img_bottom.
            </li>
            <li>
              <b
                >The function is calculating grid_row = py // square_size and
                grid_col = px // square_size, but then only uses the parity of
                grid_col (i.e., grid_col % 2) to decide between img_top and
                img_bottom.</b
              >
            </li>
            <li>
              The <code>square_size</code> parameter is being ignored, and a
              default size of 1 is being used for the pattern, but there's also
              an issue with y-coordinate processing.
            </li>
          </ol>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <p><strong>Correct Option: C</strong></p>
            <p>
              <strong>Reasoning/Student Feedback for PL:</strong>
            </p>
            <ul>
              <li>
                <b>A) Incorrect.</b> If img_top was always chosen, the output
                would just be img_top, not alternating stripes.
              </li>
              <li>
                <b>B) Incorrect.</b> If only the parity of grid_row (derived
                from py) was used, the pattern would result in horizontal
                stripes. The choice of image would change as you move down
                vertically but would remain consistent horizontally within each
                stripe. The problem describes vertical stripes.
              </li>
              <li>
                <b>C) Correct.</b> If the choice between img_top and img_bottom
                depends only on the parity of grid_col (which is (px //
                square_size) % 2), then all pixels with the same grid_col (i.e.,
                within the same vertical block of square_size width) will use
                the same source image. As grid_col itself alternates (0, 1, 2,
                ...), its parity grid_col % 2 will alternate (0, 1, 0, 1,...).
                This would create alternating vertical stripes from img_bottom
                (if, for example, grid_col % 2 == 0 maps to bottom) and img_top
                (if grid_col % 2 == 1 maps to top). This pattern matches the
                observed problem where the py coordinate (and thus grid_row) is
                being ignored in determining the final pattern structure.
              </li>
              <li>
                <b>D) Incorrect.</b> If square_size was ignored and defaulted to
                1, it would be a very fine 1x1 pattern if the rest of the logic
                was correct. The problem states the stripes are 20-pixels wide,
                implying square_size = 20 is being used for width determination,
                but not correctly for the 2D pattern.
              </li>
            </ul>
          </div>
        </div>

        <div class="question" id="q5">
          <h2>Decomposing Checkerboard Image Merge</h2>
          <p>
            <strong>Task Context:</strong> You are to design a main Python
            function
            <code
              >apply_checkerboard_merge(img_top: Image.Image, img_bottom:
              Image.Image, square_size: int) -> Image.Image</code
            >. This function will merge two input images, img_top and img_bottom
            (assumed to be of the same width and height), into a result image.
            The merging uses a checkerboard pattern where the side length of
            each square is square_size. The logic for choosing is: for a pixel
            at (px,py), first determine its grid_row = py // square_size and
            grid_col = px // square_size. If (grid_row + grid_col) is even
            (let's call this "type 0"), the corresponding pixel in result comes
            from img_bottom. If the sum is odd ("type 1"), the pixel comes from
            img_top.
          </p>
          <p>
            An example of the checkerboard pattern would look like this, suppose
            we had a solid red image and a solid green image each being having
            dimensions of 400x400 pixels. With our img_top being the solid
            green, and the img_bottom being the solid red. The resultant
            checkerboard pattern would look something like:
          </p>
          <img
            src="../assets/Image.png"
            alt="Red and Green Checkerboard Pattern"
            style="max-width: 200px; display: block; margin: 15px 0"
          />
          <p>
            <strong>Question:</strong> Recalling the principles of Problem
            Decomposition from Chapter 7, and keeping in mind that helper
            functions should encapsulate distinct, non-trivial pieces of logic
            (i.e., generally avoiding helpers that are just one-line wrappers
            for existing library calls), select ALL helper functions that would
            be most logical and effective for implementing
            create_checkerboard_merge.
          </p>
          <ol type="A">
            <li>
              <code
                >initialize_output_canvas(width: int, height: int, color_mode:
                str) -> Image.Image</code
              >: A general utility to create and return a new, blank PIL Image
              object with specified dimensions and color mode. This is
              effectively a direct call to Image.new().
            </li>
            <li>
              <b
                ><code
                  >get_square_type(px: int, py: int, square_side_length: int) ->
                  int</code
                >: (Function from QID: get_checkerboard_square_type_coding)
                Description: Calculates and returns an integer (0 or 1)
                indicating the checkerboard square type based on the pixel's
                coordinates and the square side length, using the (row+col)
                parity logic.</b
              >
            </li>
            <li>
              <code
                >get_pixel_rgb_color(source_image: Image.Image, x_coord: int,
                y_coord: int) -> tuple[int, int, int]</code
              >: Retrieves the (R,G,B) color tuple of the pixel at specified
              coordinates from a source image. This is effectively a direct call
              to source_image.getpixel().
            </li>
            <li>
              <b
                ><code
                  >select_pixel_for_overlay(top_pixel_color: tuple[int, int,
                  int], bottom_pixel_color: tuple[int, int, int], square_type:
                  int) -> tuple[int, int, int]</code
                >: (Function from QID: select_pixel_for_checkerboard_coding)
                Description: Given pixel colors from two source images and a
                square type (0 or 1), applies the rule to select and return the
                appropriate color for the final image.</b
              >
            </li>
            <li>
              <code
                >get_grid_indices_only(px: int, py: int, side_len: int) ->
                tuple[int, int]</code
              >: A partial helper that only calculates and returns the
              (grid_row, grid_col) tuple for a pixel, but does not proceed to
              determine the actual square type (0 or 1) based on these indices.
            </li>
            <li>
              <code
                >is_top_leftmost_pixel_black_for_checkerboard(square_dim: int)
                -> bool</code
              >: A highly specific one-liner style function, return
              get_square_type(0,0,square_dim) == 0, that only checks the type of
              the very first pixel of the checkerboard.
            </li>
            <li>
              <code
                >merge_images_identically(image1: Image.Image, image2:
                Image.Image) -> Image.Image</code
              >: A function that attempts to combine two images by averaging
              every corresponding pixel pair.
            </li>
          </ol>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <p><strong>Correct Options:</strong> B, D</p>
            <p>
              <strong>Reasoning (for instructors):</strong> The main function
              create_checkerboard_merge needs to perform several distinct
              logical operations. According to the guideline to avoid helpers
              that are simple one-line wrappers for existing library calls:
            </p>
            <ul>
              <li>
                <b>A) initialize_output_canvas: Incorrect.</b> While creating an
                output image is a necessary step, this function, as described,
                would simply be
                <code>return Image.new(color_mode, (width, height))</code>.
                Following the guideline to avoid one-liner wrappers for existing
                library calls, this level of abstraction is too trivial for good
                decomposition in this context. The main function can directly
                call <code>Image.new()</code>.
              </li>
              <li>
                <b>B) get_square_type: Correct.</b> This function (from QID:
                get_checkerboard_square_type_coding) encapsulates the multi-step
                logic specific to the checkerboard pattern: calculating grid row
                and column indices using integer division, summing them, and
                then determining parity using the modulo operator. This is a
                significant, reusable piece of calculation and not a simple
                one-liner.
              </li>
              <li>
                <b>C) get_pixel_rgb_color: Incorrect.</b> As described, this
                function would simply be
                <code>return source_image.getpixel((x_coord, y_coord))</code>.
                This is a direct wrapper for a PIL library method and, per the
                guideline for this course's interpretation of decomposition, is
                too simple to be considered a separate helper function. The main
                function would use <code>img_top.getpixel()</code> and
                <code>img_bottom.getpixel()</code> directly.
              </li>
              <li>
                <b>D) select_pixel_for_overlay: Correct.</b> This function (from
                QID: select_pixel_for_checkerboard_coding) encapsulates a
                distinct piece of conditional logic: choosing between two pixel
                colors based on the square_type. While the code is short (an
                if-else statement), it represents a clear decision-making step
                in the algorithm and is more than just a direct library call.
              </li>
              <li>
                <b>E) get_grid_indices_only: Incorrect.</b> This is a "partial
                child function." It performs only a part of the logic required
                by <code>get_square_type</code> (Option B). Option B is the more
                complete and useful helper as it not only gets the grid indices
                but also uses them to determine the actual square type needed
                for the decision.
              </li>
              <li>
                <b
                  >F) is_top_leftmost_pixel_black_for_checkerboard:
                  Incorrect.</b
                >
                This is a "creative one-liner" style distractor. It's far too
                specific, only checking the state of a single pixel (0,0) for a
                given square dimension. It's not a general-purpose helper useful
                for processing the entire image according to the checkerboard
                pattern.
              </li>
              <li>
                <b>G) merge_images_identically: Incorrect.</b> This function
                describes a completely different image merging strategy (pixel
                averaging) and is not relevant to the specified checkerboard
                logic.
              </li>
            </ul>
          </div>
        </div>

        <hr class="suite-divider" />
        <h2 class="suite-title">
          Question Suite 2: Driving Simulator Decomposition
        </h2>

        <div class="question" id="q6">
          <h2>Building and Decomposing a Car Simulator</h2>
          <p>
            <strong>Scenario:</strong> You're building a turn-based car
            simulator. While using the simulator, players have the choice of
            accelerating (speeding up), braking, and turning. Some properties
            about the car itself: the car has speed (float), fuel (float), and
            direction (N, S, E, W). While in the simulator, the car drives
            within some pre-specified road boundaries towards a destination, as
            if you were driving using a GPS with a predefined destination. The
            simulator ends if fuel runs out, the car crashes (hits a boundary),
            or reaches the destination.
          </p>
          <p>Some things to note:</p>
          <ul>
            <li>
              Fuel goes down at some pre-specified rate when the game starts
              (this is predefined)
            </li>
            <li>
              While the goal of the simulator is to drive within the road
              boundaries, if a user chooses to move in a direction that leads
              them to a boundary (i.e. causing a collision), this constitutes a
              crash.
            </li>
            <li>
              Like any simulation, the simulator is responsible for displaying
              current information about the simulator, (i.e. the speed, fuel
              levels, direction, and more).
            </li>
          </ul>
          <p>
            <strong>Question:</strong> Recalling the principles of Problem
            Decomposition from Chapter 7, and keeping in mind that helper
            functions should encapsulate distinct, non-trivial pieces of logic
            (i.e., generally avoiding helpers that are just one-line wrappers
            for existing library calls). Which diagram best shows a top-down
            decomposition for this simulator?
          </p>
          <div class="tree">
            <p><strong>Option A:</strong></p>
            <pre><code>run_simulation
├── initialize_simulation_state (car, environment, fuel, destination)
├── main_game_thread
│   ├── get_all_inputs
│   ├── update_all_physics
│   └── draw_everything_to_screen
└── display_game_over_reason</code></pre>
            <p><strong>Option B:</strong></p>
            <pre><code>operate_car_simulation
├── setup_simulation_parameters
│   ├── create_car_with_attributes
│   ├── define_road_layout_and_destination
│   └── set_initial_game_flags
├── simulation_engine_loop
│   ├── display_car_speed
│   ├── display_car_fuel
│   ├── display_car_direction
│   ├── get_player_action_from_keyboard
│   ├── apply_acceleration_rules
│   ├── apply_braking_rules
│   ├── apply_turning_rules
│   ├── calculate_fuel_decrease
│   ├── move_car_on_map
│   ├── check_if_fuel_is_zero
│   ├── check_if_car_hit_boundary
│   └── check_if_car_at_destination
└── show_simulation_result_message</code></pre>
            <p><strong>Option C (Correct):</strong></p>
            <ul>
              <li>
                <code>run_simulation</code>
                <ul>
                  <li>
                    <code>initialize_simulation</code>
                    <ul>
                      <li><code>create_car_state(...)</code></li>
                      <li><code>setup_environment(...)</code></li>
                    </ul>
                  </li>
                  <li>
                    <code>simulation_loop</code>
                    <ul>
                      <li><code>display_dashboard(...)</code></li>
                      <li><code>get_player_command(...)</code></li>
                      <li>
                        <code>execute_player_command</code>
                        <ul>
                          <li><code>handle_acceleration(...)</code></li>
                          <li><code>handle_braking(...)</code></li>
                          <li><code>handle_turning(...)</code></li>
                        </ul>
                      </li>
                      <li><code>update_car_state(...)</code></li>
                      <li>
                        <code>check_simulation_end_conditions</code>
                        <ul>
                          <li><code>check_fuel_status</code></li>
                          <li><code>check_boundary_violations</code></li>
                          <li><code>check_destination_reached</code></li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li><code>display_simulation_outcome(...)</code></li>
                </ul>
              </li>
            </ul>
            <p><strong>Option D:</strong></p>
            <pre><code>car_game_main
├── init_game
├── game_cycle
│   ├── handle_input
│   ├── process_logic
│   │   └── update_car
│   │       └── move_car
│   │           └── consume_fuel
│   │               └── check_collisions
│   │                   └── check_win_lose
│   └── render_status
└── end_game</code></pre>
            <p><strong>Option E:</strong></p>
            <pre><code>run_simulation_scenario
├── configure_initial_settings
│   ├── generate_car_properties
│   └── establish_world_rules (boundaries, target)
├── interactive_simulation_loop
│   ├── present_car_status_to_player // Displays dashboard
│   ├── solicit_player_driving_action // Gets command string
│   ├── interpret_and_apply_player_action // Handles accel, brake, turn
│   │   ├── process_acceleration_request
│   │   ├── process_braking_request
│   │   └── process_turning_request
│   └── evaluate_game_ending_criteria // Checks fuel, boundary, destination
│       ├── verify_sufficient_fuel
│       ├── check_for_boundary_breach
│       └── confirm_arrival_at_destination
└── announce_simulation_conclusion</code></pre>
            <p><strong>Option F:</strong></p>
            <pre><code>start_driving_experience
├── initialize_driving_session_data
│   ├── create_vehicle_state_representation
│   └── define_operational_area_and_goal
├── turn_based_game_flow
│   ├── display_vehicle_info_and_get_player_choice // Combines output and input
│   ├── resolve_player_choice_and_world_consequences
│   │   ├── adjust_vehicle_physics_and_fuel // Modifies speed, direction, and fuel together
│   │   └── update_vehicle_location_and_check_all_events 
│   └── determine_and_show_final_status_if_ended // Checks if game should end and if so, displays outcome</code></pre>
          </div>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <p><strong>Correct Option:</strong> C</p>
            <p>
              <strong>Reasoning/Student Feedback to add to PL:</strong>
            </p>
            <ul>
              <li>
                <b>A) Incorrect.</b> Functions like initialize_everything are
                too broad, hiding too much complexity and making them hard to
                manage. Good decomposition aims for smaller, focused functions.
              </li>
              <li>
                <b>B) Incorrect.</b> This diagram is too flat within
                simulation_engine_loop. Many small actions are listed
                individually instead of being grouped into logical helper
                functions (e.g., one function to update physics or display the
                dashboard).
              </li>
              <li>
                <b>C) Correct.</b> This diagram shows a balanced decomposition.
                initialize_simulation groups setup. The game_loop delegates to
                clear helper functions for distinct tasks like
                display_dashboard, execute_player_command (further broken down),
                and check_simulation_end_conditions (also broken down). This
                promotes modularity.
              </li>
              <li>
                <b>D) Incorrect.</b> This shows over-decomposition with
                confusing nesting (e.g., check_win_lose under consume_fuel).
                This can lead to tiny, overly specific functions and unclear
                task relationships.
              </li>
              <li>
                <b>E) Incorrect.</b> This decomposition appears well-structured.
                However, there's a significant functional flaw: the
                interpret_and_apply_player_action function (and its
                sub-functions) are described as only changing the car's intended
                speed/direction. The crucial step of actually moving the car
                based on these intentions and consuming fuel (like what
                update_car_state does in option C) is missing entirely from the
                loop's main logic before checking end conditions.
              </li>
              <li>
                <b>F) Incorrect.</b> While this shows multiple levels, some
                helper functions combine too many or unrelated responsibilities.
                For example, display_vehicle_info_and_get_player_choice merges
                output and input. More critically,
                update_vehicle_location_and_check_all_events tries to do too
                much: move the car, check for crashes, check fuel, and check for
                winning, all in one sub-step. These checks are distinct end
                conditions.
              </li>
            </ul>
          </div>
        </div>

        <div class="question" id="q7">
          <h2>Function Design: Updating Car State</h2>
          <p>
            <strong>Function Description:</strong> Recalling the decomposition
            options from the previous question: “ Building and Decomposing a Car
            Simulator”, we are building this helper function `update_car_state`.
            This function updates the car's position and fuel. It uses the car's
            current speed, direction, position, fuel, and a given time step. It
            should return the car's new state.
          </p>
          <p>
            <strong>Question:</strong> Which Python function prototype and
            docstring best defines update_car_state?
          </p>
          <ol type="A">
            <li>
              <b
                ><code
                  >def update_car_state(current_car_state: dict, time_step:
                  float) -> dict:</code
                ><br />
                <pre>
"""
Updates car's position and fuel based on speed, direction, and time_step.

Args:
    current_car_state: Dict with 'speed', 'direction', 'position', 'fuel'.
    time_step: Simulation step duration (e.g., seconds).
    
Returns:
    New dict with car's updated state (position, fuel).
"""</pre
                >
              </b>
            </li>
            <li>
              <code
                >def update_car_state(speed: float, direction: str, x_pos:
                float, y_pos: float, fuel: float, dt: float) -> tuple[float,
                float, float]:</code
              ><br />
              <pre>
"""
Calculates new x_pos, y_pos, and fuel based on inputs.
Args:
    speed: Current car speed.
    direction: Current car direction (e.g., "N", "E").
    x_pos: Current x-coordinate.
    y_pos: Current y-coordinate.
    fuel: Current fuel level.
    dt: Time step for the update.
Returns:
    A tuple (new_x_pos, new_y_pos, new_fuel_level).
"""</pre
              >
            </li>
            <li>
              <code>def update_car_state(car: object, time: float) -> car:</code
              ><br />
              <pre>
"""
Updates the car.
Args:
    car: The car object.
    time: Simulation time step.
Returns:
    The modified car object.
"""</pre
              >
            </li>
            <li>
              <code
                >def update_car_state(car_info: list, elapsed_time: float) ->
                list:</code
              ><br />
              <pre>
"""
Updates car_info (composed of [speed, dir_angle, x, y, fuel]) and only updates the car’s x, y position and fuel level.
Args:
    car_info: List of car's state.
    elapsed_time: Time step.
Returns:
    The modified car_info list.
"""</pre
              >
            </li>
            <li>
              <code
                >def update_car_state(car_dict: dict, time_val: float) ->
                None:</code
              ><br />
              <pre>
"""
Processes car_dict, updating position and fuel_level based on speed, 
direction (all in car_dict), and time_val. Modifies car_dict in place.

Args:
    car_dict: Dictionary with all car data.
    time_val: Time passed for this update.
Returns:
    Nothing (dictionary is changed directly).
"""</pre
              >
            </li>
            <li>
              <code
                >def update_car_state(car_state_tuple: tuple, time_slice: float)
                -> tuple:</code
              ><br />
              <pre>
"""
Updates car state (position, fuel).
Args:
    car_state_tuple: (speed, direction, (x,y), fuel).
    time_slice: The time step.
Returns:
    New tuple with updated ((x,y), fuel). Other elements may be omitted.
"""</pre
              >
            </li>
          </ol>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <p><strong>Correct Option:</strong> A</p>
            <p>
              <strong>Reasoning/Student Feedback to add to PL:</strong>
            </p>
            <ul>
              <li>
                <b>A) Correct.</b> Uses a dictionary for current_car_state,
                clearly passing structured data. The docstring specifies
                expected keys/types and behavior. Returning a new dictionary for
                the updated state is good practice for data flow clarity.
              </li>
              <li>
                <b>B) Incorrect.</b> This function returns a tuple of selected
                new values but takes many individual parameters. Passing a
                structured data type (like a dict) for the car's state is
                generally preferred over many separate parameters for better
                organization. Also, does the return tuple represent the entire
                new state or just parts?
              </li>
              <li>
                <b>C) Incorrect.</b> The docstring "Updates the car" is too
                vague. It doesn't specify what car attributes are changed or its
                expected structure.
              </li>
              <li>
                <b>D) Incorrect.</b> Using a list (car_info) and relying on
                element order (indices) is error-prone and less readable than a
                dictionary with named keys.
              </li>
              <li>
                <b>E) Incorrect.</b> Modifying a dictionary in-place (a side
                effect) can be less clear in terms of decomp rather than just
                returning a new state.
              </li>
              <li>
                <b>F) Incorrect.</b> The return description "Other elements may
                be omitted" is ambiguous. Returning the complete, updated state
                structure is usually clearer.
              </li>
            </ul>
          </div>
        </div>

        <div class="question" id="q8">
          <h2>Function Design: Checking Fuel Status</h2>
          <p>
            <strong>Function Description:</strong> Recalling the decomposition
            options from the previous question: “ Building and Decomposing a Car
            Simulator”, we are building this helper function, we are attempting
            to build the `check_fuel_status` function. This helper function
            checks if the car is out of fuel. It takes the car's current fuel
            level and should properly indicate whether or not the car is out of
            fuel. NOTE: This is part of a larger check_simulation_end_conditions
            function.
          </p>
          <p>
            <strong>Question:</strong> Which Python function prototype and
            docstring best defines check_fuel_status?
          </p>
          <ol type="A">
            <li>
              <code>def check_fuel_status(car_object) -> str:</code><br />
              <pre>
"""
Checks car_object's fuel attribute.
Args:
    car_object: The car object.
Returns:
    "OUT_OF_FUEL" if fuel <= 0, "OK" otherwise.
"""</pre
              >
            </li>
            <li>
              <b
                ><code
                  >def check_fuel_status(current_fuel_level: float) ->
                  bool:</code
                ><br />
                <pre>
"""
Determines if the car is out of fuel.

Args:
    current_fuel_level: Car's current fuel (non-negative float).
    
Returns:
    True if current_fuel_level <= 0 (out of fuel).
    False if current_fuel_level > 0.
"""</pre
                >
              </b>
            </li>
            <li>
              <code
                >def check_fuel_status(fuel: float, car_state: dict) ->
                bool:</code
              ><br />
              <pre>
"""
Checks fuel. Updates car_state if out of fuel.
Args:
    fuel: Current fuel.
    car_state: Car's state dictionary.
Returns:
    True if out of fuel.
"""</pre
              >
            </li>
            <li>
              <code>def check_fuel_status(all_game_data: dict) -> bool:</code
              ><br />
              <pre>
"""
Accesses fuel level from a nested structure within all_game_data 
(e.g., all_game_data['car']['fuel']).
Args:
    all_game_data: A dictionary containing all game state.
Returns:
    Boolean: True if car's fuel is depleted, False otherwise.
"""</pre
              >
            </li>
            <li>
              <code>def check_fuel_status(fuel_amount: float) -> int:</code
              ><br />
              <pre>
"""
Checks fuel.
Args:
    fuel_amount: Current fuel.
Returns:
    1 if out of fuel, 0 if fuel is available.
"""</pre
              >
            </li>
            <li>
              <code>def check_fuel_status(car_stats: list[float]) -> bool:</code
              ><br />
              <pre>
"""
Checks fuel level (second element in car_stats).
Args:
    car_stats: List where car_stats[1] is fuel.
Returns:
    True if fuel (car_stats[1]) <= 0, else False.
"""</pre
              >
            </li>
          </ol>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <p><strong>Correct Option:</strong> B</p>
            <p>
              <strong>Reasoning/Student Feedback to add to PL:</strong>
            </p>
            <ul>
              <li>
                <b>A) Incorrect.</b> Returning strings ("OUT_OF_FUEL", "OK") is
                less standard for boolean checks than True/False, which are more
                direct for conditions.
              </li>
              <li>
                <b>B) Correct.</b> Takes only the needed data
                (current_fuel_level) and returns a clear boolean. The docstring
                is clear. This is a good, small, well-defined helper function.
              </li>
              <li>
                <b>C) Incorrect.</b> If fuel is the specific level, car_state is
                redundant here. "Updates car_state" is an unexpected side effect
                for a "check" function; it should ideally not modify state.
              </li>
              <li>
                <b>D) Incorrect.</b> This function only relies on the current
                fuel level, so it is a bit excessive to pass the entire game
                state to this helper function.
              </li>
              <li>
                <b>E) Incorrect.</b> Returning 1 for true and 0 for false while
                still valid, is less “indicative”. (Think: why would we return
                an int when we can use another data type)?
              </li>
              <li>
                <b>F) Incorrect.</b> Accessing fuel via car_stats[1] (an index)
                is less readable and more error-prone than using a dictionary
                key or a dedicated parameter.
              </li>
            </ul>
          </div>
        </div>

        <hr class="suite-divider" />
        <h2 class="suite-title">Question Suite 3: Daily Schedule Planner</h2>

        <div class="question" id="q9">
          <h2>Decomposition: Structuring the Daily Schedule Planner</h2>
          <p>
            <strong>Scenario:</strong> You're building a daily schedule planner
            program. Expected capabilities of the program are that users can:
          </p>
          <ol>
            <li>
              Add tasks (description, start time "HH:MM", duration in minutes).
            </li>
            <li>View tasks (sorted by time).</li>
            <li>Remove tasks.</li>
            <li>
              The system must prevent adding tasks that overlap in time. The
              schedule holds all of these tasks in a dictionary where the format
              is a list where each item is a dictionary holding a task's
              details.
            </li>
          </ol>
          <p>
            <strong>Question:</strong> Recalling the principles of Problem
            Decomposition from Chapter 7, which diagram best shows a top-down
            decomposition(you can refer to Chapter 7 to remember what a top-down
            decomposition is)? Aim for manageable functions with distinct
            responsibilities, avoiding overly broad or trivial helper functions.
          </p>
          <div class="tree">
            <p><strong>Option A:</strong></p>
            <pre><code>scheduler_application_start
├── create_empty_schedule
├── main_interactive_session
│   └── process_all_user_actions_and_schedule_logic (a single, large function to handle everything: add, view, remove, conflict check, user input, screen output)
└── display_application_closed_message</code></pre>
            <p><strong>Option B:</strong></p>
            <pre><code>run_daily_schedule_planner
├── prepare_internal_schedule_storage
├── core_scheduler_user_interaction_loop
│   ├── show_available_actions_on_screen
│   ├── get_user_text_command_choice
│   ├── if_user_chooses_add_new_task:
│   │   ├── ask_for_task_description_text
│   │   ├── ask_for_task_start_time_text
│   │   ├── ask_for_task_duration_text
│   │   ├── perform_all_input_validations_in_this_block
│   │   ├── perform_all_time_conversions_in_this_block
│   │   ├── perform_entire_conflict_check_logic_in_this_block
│   │   └── add_new_task_data_to_internal_schedule_if_all_ok
│   ├── if_user_chooses_view_all_tasks:
│   │   └── iterate_through_schedule_and_print_all_details
│   └── if_user_chooses_remove_a_task:
│       └── ask_for_task_to_remove_and_delete_from_internal_schedule</code></pre>
            <p><strong>Option C:</strong></p>
            <pre><code>schedule_management_utility_run
├── obtain_user_instruction_as_one_line_text // e.g., "ADD New Event,14:30,45" or "VIEW SCHEDULE"
├── primary_command_interpreter_and_executor_function // A single, complex function that parses the instruction text and then performs all associated logic for every possible instruction (validation, conflict detection, schedule list changes, screen output).
└── show_final_status_or_error_on_screen</code></pre>
            <p><strong>Option D (Correct):</strong></p>
            <pre><code>run_schedule_planner
├── initialize_schedule // Creates an empty list for task data
├── scheduler_main_loop
│   ├── display_main_menu // Shows user options like "add", "view", "exit"
│   ├── get_menu_selection // Gets the user's string choice
│   ├── handle_menu_selection // Directs to other functions based on choice
│   │   ├── execute_add_new_task_workflow
│   │   │   ├── get_task_details_from_user // Prompts for description, start time, duration as strings
│   │   │   ├── validate_and_parse_task_inputs // Checks string formats, converts time to a usable numeric form (e.g., minutes from midnight)
│   │   │   ├── check_for_time_conflict // Compares new task's numeric times with existing tasks in the schedule
│   │   │   └── add_task_record_to_schedule // Appends task data (e.g., a dictionary) to the schedule list if all checks pass
│   │   ├── execute_display_schedule_workflow
│   │   │   └── format_task_for_display // Helper function to create a consistently formatted, readable string for each task
│   │   ├── execute_remove_task_workflow
│   │   │   ├── get_task_identifier_for_deletion // Asks user how to identify the task to remove
│   │   │   └── find_and_delete_task // Searches the schedule list and removes the specified task data
│   │   └── handle_exit_option
└── (Program ends when user exits loop)</code></pre>
            <p><strong>Option E:</strong></p>
            <pre><code>initiate_schedule_program
├── setup_empty_schedule_list
├── main_user_command_cycle
│   ├── present_command_choices_to_user
│   ├── get_user_menu_action_choice
│   ├── if_action_is_add_task:
│   │   ├── obtain_raw_task_input_strings_from_user // Gets description, start_str, duration_str
│   │   ├── convert_strings_and_validate_data_types // Parses time/duration to numbers, basic validation
│   │   └── append_new_task_to_schedule_list // Adds task record (e.g., dictionary) to list
│   ├── if_action_is_view_schedule:
│   │   └── prepare_and_display_all_tasks
│   └── if_action_is_remove_task:
│       └── request_identifier_and_remove_task_from_list
└── terminate_program_execution_cleanly</code></pre>
            <p><strong>Option F:</strong></p>
            <pre><code>start_scheduler_interaction_flow
├── create_new_empty_task_collection
├── primary_application_loop_handler
│   ├── display_interactive_user_menu
│   ├── accept_user_menu_option
│   ├── route_user_option_to_handler
│   │   ├── process_new_task_entry_and_initial_checks // Gets all task input strings AND performs basic format validation
│   │   ├── analyze_schedule_availability_and_store_task // Converts times for new task, checks ALL conflicts, AND adds to schedule if clear
│   │   ├── compile_and_output_schedule_report_or_get_removal_target // Formats entire schedule for viewing OR prompts user for which task to remove based on mode
│   │   └── execute_task_deletion_from_collection // Performs the actual removal
└── display_program_exit_message</code></pre>
          </div>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <p><strong>Correct Option:</strong> D</p>
            <p>
              <strong>Reasoning/Student Feedback:</strong>
            </p>
            <ul>
              <li>
                <b>A) Incorrect.</b>
                <code>process_all_user_actions_and_schedule_logic</code> is too
                broad. Effective decomposition involves breaking such large
                problems into smaller, distinct subproblems.
              </li>
              <li>
                <b>B) Incorrect.</b> The
                <code>if_user_chooses_add_new_task:</code> is somewhat
                decomposed, we have a bunch of helper functions, but
                functionally this can be split up into “processing input”,
                “validation”, and “execution”. We can add another layer of
                functions that separates these processes for us.
              </li>
              <li>
                <b>C) Incorrect.</b> The
                <code>primary_command_interpreter_and_executor_function</code>
                is too complex as it tries to handle parsing, validation, logic,
                and list manipulation for all command types in one place. This
                makes it difficult to manage.
              </li>
              <li>
                <b>D) Correct.</b> This diagram shows a balanced decomposition.
                <code>handle_menu_selection</code> appropriately delegates to
                distinct "workflow" functions (like
                <code>execute_add_new_task_workflow</code>), which are then
                further broken down into specific, logical helper functions,
                each with a clear responsibility. This aligns with top-down
                design principles.
              </li>
              <li>
                <b>E) Incorrect.</b> This decomposition looks well-structured
                because it breaks down the "add task" process. However, inspect
                the sequence of operations carefully. Is there a crucial step
                missing in the <code>if_action_is_add_task</code> block before a
                task is actually added to the schedule? (Hint: Review the
                program requirements.)
              </li>
              <li>
                <b>F) Incorrect.</b> While this diagram shows functions being
                called, some helper functions appear to combine too many
                responsibilities. For example,
                <code>process_new_task_entry_and_initial_checks</code> does both
                input gathering and validation.
                <code
                  >compile_and_output_schedule_report_or_get_removal_target</code
                >
                tries to serve two very different user actions (viewing vs.
                initiating removal). Why should functions ideally have a single,
                clear purpose?
              </li>
            </ul>
          </div>
        </div>

        <div class="question" id="q10">
          <h2>Function Design: Parsing and Validating Task Start Time</h2>
          <p>
            <strong>Function Description:</strong> Recalling the Decomposition
            Problem from the previous question, let’s propose a helper function
            that could be used in some of the options above:,
            <code>parse_and_validate_start_time</code>, which would be found in
            the "add task" workflow. It receives a single string,
            <code>time_str</code>, which is the user's input for the task's
            start time (expected format "HH:MM", e.g., "09:45"). Its tasks are:
          </p>
          <ol>
            <li>
              Verify <code>time_str</code> matches the "HH:MM" pattern (e.g.,
              correct length, colon in the middle, digits for HH and MM).
            </li>
            <li>If the pattern is correct, extract HH and MM as integers.</li>
            <li>
              Ensure HH is between 00 and 23 (inclusive) and MM is between 00
              and 59 (inclusive).
            </li>
            <li>
              If all checks pass, it should return the time converted to total
              minutes from midnight (integer). For example, "01:00" becomes 60.
              If any check fails (invalid format or invalid hour/minute values),
              it must indicate this failure, and return None.
            </li>
          </ol>
          <p>
            <strong>Question:</strong> Which Python function prototype and
            docstring best defines parse_and_validate_start_time?
          </p>
          <ol type="A">
            <li>
              <code
                >def parse_and_validate_start_time(time_str: str) -> int |
                None:</code
              ><br />
              <pre>
"""
Checks if "HH:MM" format is valid. If so, returns number of characters parsed.
Args:
    time_str: The start time string.
Returns:
    Length of time_str (an int, e.g., 5) if format appears like "HH:MM".
    Returns None if format is grossly incorrect (e.g., wrong length).
"""</pre
              >
            </li>
            <li>
              <code
                >def parse_and_validate_start_time(time_str: str) -> int:</code
              ><br />
              <pre>
"""
Parses "HH:MM" to minutes. Assumes input is always perfectly valid.
Args:
    time_str: A guaranteed valid "HH:MM" string.
Returns:
    Total minutes from midnight. (No error checking described).
"""</pre
              >
            </li>
            <li>
              <code
                >def parse_and_validate_start_time(time_str: str) -> tuple[bool,
                int, str]:</code
              ><br />
              <pre>
"""
Validates and parses "HH:MM" time string.
Args:
    time_str: The start time string.
Returns:
    A tuple: (isValid: bool, minutes: int, status_message: str).
    'minutes' is 0 if invalid. 'status_message' explains error or "OK".
"""</pre
              >
            </li>
            <li>
              <code
                >def parse_and_validate_start_time(hours: int, minutes: int) ->
                int | None:</code
              ><br />
              <pre>
"""
Validates pre-parsed integer hours (0-23) and minutes (0-59).
Converts to total minutes from midnight if valid.
Args:
    hours: Integer hour.
    minutes: Integer minute.
Returns:
    Total minutes from midnight (int) or None if hour/minute out of range.
"""</pre
              >
            </li>
            <li>
              <code
                >def parse_and_validate_start_time(time_str: str) -> bool |
                int:</code
              ><br />
              <pre>
"""
If time_str ("HH:MM") is valid, returns total minutes (int).
If invalid, returns False.
Args:
    time_str: The start time string.
Returns:
    Total minutes from midnight (int) upon successful validation and parsing,
    or False if any validation (format, hour range, minute range) fails.
"""</pre
              >
            </li>
            <li>
              <code
                >def parse_and_validate_start_time(time_components: list[str])
                -> int:</code
              ><br />
              <pre>
"""
Takes a list of strings, e.g., ["HH", "MM"]. Validates and converts.
Prints error to console and returns -1 if invalid.
Args:
    time_components: List containing hour string and minute string.
Returns:
    Total minutes from midnight, or -1 on error.
"""</pre
              >
            </li>
            <li>
              <b
                ><code
                  >def parse_and_validate_start_time(time_str: str) -> int |
                  None:</code
                ><br />
                <pre>
"""
Parses an "HH:MM" time string to total minutes from midnight if valid.
Checks "HH:MM" format, hour (0-23), and minute (0-59) validity.

Args:
    time_str: The start time string from user input (e.g., "09:45").
    
Returns:
    Total minutes from midnight (int) if time_str is valid and represents
    a real time. Returns None if format or time values are invalid.
"""</pre
                >
              </b>
            </li>
            <li>
              <code
                >def parse_and_validate_start_time(time_str: str) -> None:</code
              ><br />
              <pre>
"""
Parses "HH:MM" time string. Checks format.
Validates hour (0-23) and minute (0-59).
Args:
    time_str: The start time string (e.g., "09:45").
Returns:
    Always returns None after printing validation status and parsed minutes if valid.
    (Intended for direct console output, not returning parsed value for use).
"""</pre
              >
            </li>
            <li>
              <code
                >def parse_and_validate_start_time(time_str: str) -> int |
                None:</code
              ><br />
              <pre>
"""
Validates "HH:MM" format, hour (0-23), and minute (0-59).
Args:
    time_str: The start time string (e.g., "09:45").
Returns:
    Returns 0 (as an int) if time_str is valid.
    Returns None if format or time values are invalid.
    (Does not return the actual minutes from midnight).
"""</pre
              >
            </li>
          </ol>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <p><strong>Correct Option:</strong> G</p>
            <p>
              <strong>Reasoning/Student Feedback:</strong>
            </p>
            <ul>
              <li>
                <b>A) Incorrect.</b> This function has the correct return type
                signature (int | None), but its described behavior is flawed. It
                claims to return the length of the string if the format seems
                okay, not the parsed time in minutes. It also states it doesn't
                validate HH/MM values properly. A parsing function must return
                the actual parsed and validated data.
              </li>
              <li>
                <b>B) Incorrect.</b> The docstring "Assumes input is always
                perfectly valid" and "No error checking described" contradicts
                the function's core responsibility of validating the input
                string. A correct parsing function must handle potential errors.
              </li>
              <li>
                <b>C) Incorrect.</b> While returning a tuple with a status
                message can be informative, it makes the return type more
                complex. For instance, the caller always gets a tuple and has to
                unpack it and check the boolean and the message. Returning data
                or None (as in A) is often simpler for the caller to check:
                <code>result = parse_(...); if result is None: ...</code>.
              </li>
              <li>
                <b>D) Incorrect.</b> This function expects hours and minutes as
                separate, already parsed integers. The described function needs
                to parse these from the initial time_str like "HH:MM". This
                option offloads the string parsing and splitting task, which is
                part of the original function's job.
              </li>
              <li>
                <b>E) Incorrect.</b> Returning False (a boolean) for failure and
                an int for success results in a mixed-type return that can be
                slightly more awkward for the caller to handle with type
                checking than <code>int | None</code>. <code>None</code> is a
                more conventional way to indicate "no valid integer result."
              </li>
              <li>
                <b>F) Incorrect.</b> This function expects the time string to be
                pre-split into a list ["HH", "MM"]. The described function
                should handle the raw "HH:MM" string. Also, printing errors to
                the console within a parsing/validation function and returning a
                magic number like -1 is generally less flexible than returning
                <code>None</code> and letting the caller decide on error
                handling.
              </li>
              <li>
                <b>G) Correct.</b> This function description accurately reflects
                the function's described responsibilities: it takes the single
                time string, performs all necessary format and range
                validations, and returns either the successfully parsed integer
                (minutes from midnight) or <code>None</code> to clearly signal
                any failure. This value or <code>None</code> pattern is a common
                and effective way to handle validation outcomes.
              </li>
              <li>
                <b>H) Incorrect.</b> The function is described to always return
                <code>None</code>, even if parsing and validation are
                successful. A function that successfully parses data should
                return that data for the caller to use, not just print it.
              </li>
              <li>
                <b>I) Incorrect.</b> This function returns 0 (an int) if the
                time_str is valid, but this 0 does not represent the parsed time
                in minutes from midnight (unless the time was "00:00"). The
                function fails to return the actual converted time value as
                required.
              </li>
            </ul>
          </div>
        </div>

        <div class="question" id="q11">
          <h2>Function Design: Finding and Deleting a Task</h2>
          <p>
            <strong>Function Description:</strong> From the Schedule Planner's
            "remove task" workflow, the
            <code>find_and_delete_task</code> function is responsible for
            removing a specific task from the
            <code>current_schedule</code> (which is a list of task records,
            e.g., dictionaries). This function needs:
          </p>
          <ol>
            <li>The <code>current_schedule</code> list.</li>
            <li>
              An identifier for the task to be deleted. For simplicity, assume
              this identifier is the exact description string of the task to
              remove. The function should search the
              <code>current_schedule</code> for the first task record whose
              'description' matches the identifier.
            </li>
            <li>
              If found, the task record should be removed from the
              <code>current_schedule</code> list (the list is modified
              in-place). The function should then indicate success.
            </li>
            <li>
              If no task with that description is found, the list remains
              unchanged, and the function should indicate failure by returning
              <code>False</code>.
            </li>
          </ol>
          <p>
            <strong>Question:</strong> Which Python function prototype and
            docstring best defines find_and_delete_task?
          </p>
          <ol type="A">
            <li>
              <code
                >def find_and_delete_task(schedule: list[dict], description_key:
                str, value_to_match: str) -> tuple[list[dict], bool]:</code
              ><br />
              <pre>
"""
General purpose find and delete. Removes all tasks where task[description_key] == value_to_match.
Args:
    schedule: List of task dicts.
    description_key: The key to check in each dict (e.g., 'description').
    value_to_match: The value to match for deletion.
Returns:
    A tuple: (modified_schedule_list, was_any_task_removed_bool).
    The returned list is always a new list.
"""</pre
              >
            </li>
            <li>
              <code
                >def find_and_delete_task(schedule: list, description: str) ->
                list:</code
              ><br />
              <pre>
"""
Removes task by description.
Args:
    schedule: The list of tasks.
    description: Task description to find.
Returns:
    A new list with the task removed. Original list is NOT modified.
    If task not found, returns a copy of the original list.
"""</pre
              >
            </li>
            <li>
              <code
                >def find_and_delete_task(schedule: list[dict], task_id: int) ->
                dict | None:</code
              ><br />
              <pre>
"""
Removes task by its integer index (task_id) from the schedule.
Args:
    schedule: List of task dictionaries.
    task_id: The numerical index of the task to remove.
Returns:
    The removed task dictionary if successful (and index was valid), 
    None if index was out of bounds or task not found.
"""</pre
              >
            </li>
            <li>
              <code
                >def find_and_delete_task(schedule: list, task_to_remove: dict)
                -> bool:</code
              ><br />
              <pre>
"""
Removes the exact task_to_remove dictionary object from the schedule.
Assumes task_to_remove is one of the dictionary objects present in the schedule.
Args:
    schedule: The list of tasks.
    task_to_remove: The actual dictionary object to remove.
Returns:
    True if removal was successful (object found), False if object not in list.
"""</pre
              >
            </li>
            <li>
              <code
                >def find_and_delete_task(current_schedule: list, identifier:
                str) -> None:</code
              ><br />
              <pre>
"""
Searches for task by identifier (description) and removes it.
Prints status ("Removed" or "Not found") to console.
Args:
    current_schedule: The schedule list (modified in-place).
    identifier: The task description.
Returns:
    None.
"""</pre
              >
            </li>
            <li>
              <b
                ><code
                  >def find_and_delete_task(current_schedule: list[dict],
                  task_description_to_remove: str) -> bool:</code
                ><br />
                <pre>
"""
Finds and removes the first task matching task_description_to_remove 
from current_schedule. Modifies current_schedule in-place.

Args:
    current_schedule: List of task dictionaries. Each dict is expected
                      to have a 'description' key.
    task_description_to_remove: The description of the task to delete.
    
Returns:
    True if a task was found and removed, False otherwise.
"""</pre
                >
              </b>
            </li>
          </ol>
          <button class="toggle-feedback">Show Feedback</button>
          <div class="feedback" style="display: none">
            <p><strong>Correct Option:</strong> F</p>
            <p>
              <strong>Reasoning/Student Feedback:</strong>
            </p>
            <ul>
              <li>
                <b>A) Incorrect.</b> This function is described as a "General
                purpose find and delete" and takes a description_key_to_use. Is
                this level of generality required by the problem description, or
                does it ask for a more specific function? Also, check if it
                modifies the list in-place or returns a new one.
              </li>
              <li>
                <b>B) Incorrect.</b> The problem description states that the
                <code>current_schedule</code> list is modified directly
                (in-place). This option returns a new list and claims the
                original is not modified. Does this match the requirements?
              </li>
              <li>
                <b>C) Incorrect.</b> This function uses an integer
                <code>task_id</code> (an index) to find the task. What does the
                problem description say should be used to identify the task for
                removal?
              </li>
              <li>
                <b>D) Incorrect.</b> This option expects
                <code>task_to_remove</code> to be the actual dictionary object
                itself. The problem asks to find the task using its description
                string. How are these two methods of identification different?
              </li>
              <li>
                <b>E) Incorrect.</b> If the function returns
                <code>None</code> and only prints the status, how can the part
                of the program that called this function know whether the task
                was actually removed or not? Why might a return value be more
                useful here?
              </li>
              <li>
                <b>F) Correct.</b> This option correctly takes the schedule list
                and task description, modifies the list in-place as specified,
                and returns a boolean to signal if the deletion occurred. The
                docstring clearly matches this behavior.
              </li>
            </ul>
          </div>
        </div>
      </main>
    </div>
    <script src="../lib/highlight/highlight.min.js"></script>
    <script src="../js/main.js"></script>
  </body>
</html>
